<script src="Three.js"></script>

<body style ='margin:0;'>

</body>    

<script>
    var mouseDownAt;
    var mouseButtonDown = false;
    var previousEvent;
    var camera, scene, renderer,
    geometry, material, mesh;
            var matrix = new THREE.Matrix4();
        //m.makeRotationY(0.1);
        //matrix.makeRotationX(0.01); 
        matrix.setRotationFromEuler(new THREE.Vector3(0.0,0.01,0.0))
        //matrix.makeRotationY(0.01); 
        //matrix.multiplySelf(matrix.makeRotationX(0.01)); 

    
    init();
    animate();
 
    function Cubie(cube, type, orientation, position, color_front, color_up, color_side, post_rotation_matrix, meshes_array){
      this.all_meshes = new THREE.Object3D();

      this.prepare_mesh = function(geometry, color, orientation, meshes_array){
        var mesh = new THREE.Mesh(geometry, Cubie.prototype.materials[color]);
        var mesh_matrix = new THREE.Matrix4();
        if (orientation != undefined){
          mesh_matrix.setRotationFromEuler(orientation);
        }
        mesh.applyMatrix(mesh_matrix);
        scope.all_meshes.add(mesh);
        if (meshes_array != undefined){
          meshes_array.push(mesh);
        }
        mesh.cubie = this;
        mesh.color = color;
      }  

      this.load_mesh = function (type, color, orientation, meshes_array ){
        if (Cubie.prototype.mesh_files[type] == undefined) {
            loader.load(Cubie.prototype.mesh_filenames[type], function(geometry){
            Cubie.prototype.mesh_files[type] = geometry;
            scope.prepare_mesh(geometry, color, orientation, meshes_array);
          });
        }
       else{
         scope.prepare_mesh(geometry, color, orientation, meshes_array);
       }   
      }

      this.applyMatrix = function applyMatrix(matrix){
        this.all_meshes.applyMatrix(matrix);
      } 
       
      this.type = type;
      this.orientation = orientation;


      if( typeof Cubie.prototype.initialized == "undefined" ) { 
        Cubie.prototype.initialized  = 0;
        Cubie.prototype.mesh_files = [];
        Cubie.prototype.materials = [new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffffff, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xff0000, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0x00ff00, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0x0000ff, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffff00, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffa500, overdraw: true})]
        Cubie.prototype.mesh_filenames = ['rubik_corner.js','rubik_edge.js','rubik_side.js','sticker.js'];
        Cubie.prototype.initialized = true;
      }; 

      var scope = this;
      this.rotationMatrix = new THREE.Matrix4();
      this.matrix = new THREE.Matrix4();
      this.matrix.setRotationFromEuler(orientation);
      this.matrix.setPosition(position);
      
      this.load_mesh(type, Cubie.BLACK);  
      
      if (color_front != undefined){
          this.load_mesh(Cubie.STICKER, color_front, new THREE.Vector3(0,0,0), cube.cubies_meshes);
      }
      if (color_up != undefined){
        this.load_mesh(Cubie.STICKER, color_up, new THREE.Vector3(-Math.PI/2,0,0), cube.cubies_meshes);
      }
      if (color_side != undefined){
        this.load_mesh(Cubie.STICKER, color_side, new THREE.Vector3(0, Math.PI/2,0), cube.cubies_meshes);
      }

      this.all_meshes.applyMatrix(this.matrix);
      if (post_rotation_matrix != undefined){
        this.all_meshes.applyMatrix(post_rotation_matrix);
      }
      this.all_meshes.cubie = this
      cube.objects.add(this.all_meshes);
    };

    function Cube(scene,size){
      this.cubies_meshes = [];
      this.objects = new THREE.Object3D();
      this.scene = scene;
      this.init_center = function (orientation, color){

        center_x = -this.max_position +2;
        center_y = -this.max_position +2;
        center_z = this.max_position;
        i=this.cubies.length;

        post_rotation_matrix = new THREE.Matrix4();
        post_rotation_matrix.setRotationFromEuler(orientation);
        
        for(x = 0; x < size -2; x++){
          for(y = 0; y < size -2; y++){
            this.cubies[i++] = new Cubie(this, Cubie.SIDE, new THREE.Vector3(0,0,0), new THREE.Vector3(center_x,center_y,center_z), color, null, null, post_rotation_matrix);
            center_x+=2;
          }
          center_y+=2;
          center_x= -this.max_position +2;
        }        
      }

      this.init_border = function (orientation, color_front, color_up){
        center_x = -this.max_position +2;
        center_y = this.max_position;
        center_z = this.max_position;
        i=this.cubies.length;

        post_rotation_matrix = new THREE.Matrix4();
        post_rotation_matrix.setRotationFromEuler(orientation);
        
        for(x = 0; x < size -2; x++){
          this.cubies[i++] = new Cubie(this, Cubie.EDGE, new THREE.Vector3(0,0,0), new THREE.Vector3(center_x,center_y,center_z), color_front, color_up, null, post_rotation_matrix);
          center_x+=2;
        }
      }

      this.getMatrix = function(){
        return this.objects.matrix;
      }

      this.getLayer= function(axis, position){
         coordinate_position = -this.max_position + position*2;
         var layer = new Array();

         for (i=0; i < this.cubies.length; i++){
            p = this.cubies[i].all_meshes.matrix.getPosition();
            if(Math.round(eval('p.'+axis)) == coordinate_position) { layer.push(this.cubies[i]);}
         }
         return layer; 
      } 

      this.rotateLayer = function(axis,position, angle){
        var m = new THREE.Matrix4();
        switch(axis){
          case 'x':
            m.setRotationFromEuler(new THREE.Vector3(angle,0,0));
            break;
          case 'y':
            m.setRotationFromEuler(new THREE.Vector3(0,angle,0));
            break;          
          case 'z':
            m.setRotationFromEuler(new THREE.Vector3(0,0,angle));
            break;          
        };    
      //  m.multiplySelf(cube.objects.matrix)
        layer = this.getLayer(axis, position);
        for (i=0; i < layer.length; i++){
          layer[i].all_meshes.applyMatrix(m);
         // layer[i].rotationMatrix.multiplySelf(m);
       //   layer[i].all_meshes.updateMatrix();
        }
      }

      this.size = size;
      this.globalRotationAngle = new THREE.Vector3(0,0,0);
      this.cubies = new Array();


      this.half_width = Math.floor(size/2); 
      this.max_position = this.half_width*2 - (1- size%2);
  
      //front upper left
      position = new THREE.Vector3(-this.max_position , this.max_position, this.max_position)  
      this.cubies[0] = new Cubie(this, Cubie.CORNER, new THREE.Vector3(0,0,Math.PI / 2),position, Cubie.RED, Cubie.YELLOW,Cubie.GREEN);
      //front upper right
      position = new THREE.Vector3(this.max_position , this.max_position, this.max_position)  
      this.cubies[1] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,0),position, Cubie.RED, Cubie.GREEN, Cubie.WHITE);
      //front bottom left
      position = new THREE.Vector3(-this.max_position , -this.max_position, this.max_position)  
      this.cubies[2] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,-Math.PI), position, Cubie.RED, Cubie.BLUE,Cubie.YELLOW);
      //front bottom right
      position = new THREE.Vector3(this.max_position , -this.max_position, this.max_position)  
      this.cubies[3]= new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,-Math.PI /2), position, Cubie.RED, Cubie.WHITE, Cubie.BLUE);

      //back upper left
      position = new THREE.Vector3(-this.max_position , this.max_position, -this.max_position)  
      this.cubies[4] = new Cubie(this, Cubie.CORNER, new THREE.Vector3(Math.PI,0,Math.PI),position, Cubie.ORANGE, Cubie.GREEN,Cubie.YELLOW);
      //back upper right
      position = new THREE.Vector3(this.max_position , this.max_position, -this.max_position)  
      this.cubies[5] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0,-Math.PI/2),position, Cubie.ORANGE, Cubie.WHITE, Cubie.GREEN);
   
      //back bottom left
      position = new THREE.Vector3(-this.max_position , -this.max_position, -this.max_position)  
      this.cubies[6] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0,-3/2 *Math.PI), position, Cubie.ORANGE, Cubie.YELLOW, Cubie.BLUE);
   
      //back bottom right
      position = new THREE.Vector3(this.max_position , -this.max_position, -this.max_position)  
      this.cubies[7]= new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0, 0 ), position, Cubie.ORANGE, Cubie.BLUE, Cubie.WHITE);

      this.init_center(new THREE.Vector3(0,0,0),Cubie.RED);
      this.init_center(new THREE.Vector3(Math.PI/2,0,0),Cubie.BLUE);
      this.init_center(new THREE.Vector3(-Math.PI/2,0,0),Cubie.GREEN);
      this.init_center(new THREE.Vector3(Math.PI,0,0),Cubie.ORANGE);

      this.init_center(new THREE.Vector3(0,-Math.PI/2,0),Cubie.YELLOW);
      this.init_center(new THREE.Vector3(0,Math.PI/2,0),Cubie.WHITE);

      this.init_border(new THREE.Vector3(0,0,0),Cubie.RED, Cubie.GREEN);
      this.init_border(new THREE.Vector3(Math.PI/2,0,0), Cubie.BLUE, Cubie.RED);
      this.init_border(new THREE.Vector3(-Math.PI/2,0,0), Cubie.GREEN, Cubie.ORANGE);
      this.init_border(new THREE.Vector3(Math.PI,0,0), Cubie.ORANGE, Cubie.BLUE);

      this.init_border(new THREE.Vector3(0,-Math.PI/2,0),Cubie.YELLOW, Cubie.GREEN);
      this.init_border(new THREE.Vector3(0,Math.PI/2,0),Cubie.WHITE, Cubie.GREEN);

      this.init_border(new THREE.Vector3(0,0,Math.PI/2),Cubie.RED, Cubie.YELLOW);
      this.init_border(new THREE.Vector3(0,0,-Math.PI/2),Cubie.RED, Cubie.WHITE);

      this.init_border(new THREE.Vector3(0,Math.PI,Math.PI/2),Cubie.ORANGE, Cubie.WHITE);
      this.init_border(new THREE.Vector3(0,Math.PI,-Math.PI/2),Cubie.ORANGE, Cubie.YELLOW);

      this.init_border(new THREE.Vector3(Math.PI,-Math.PI/2,0),Cubie.YELLOW, Cubie.BLUE);
      this.init_border(new THREE.Vector3(Math.PI,Math.PI/2,0),Cubie.WHITE, Cubie.BLUE);

      this.applyMatrix=  function applyMatrix(matrix){
        this.objects.applyMatrix(matrix); 
      }
    }

     
    function init() {
        Cubie.CORNER = 0;
        Cubie.EDGE = 1;
        Cubie.SIDE= 2;
        Cubie.STICKER = 3;

        Cubie.BLACK = 0;
        Cubie.WHITE = 1;
        Cubie.RED =   2;
        Cubie.GREEN = 3;
        Cubie.BLUE =  4;
        Cubie.YELLOW =5;
        Cubie.ORANGE =6; 



        loader = new THREE.JSONLoader();

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );


        var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); 
        directionalLight.position.set( 0, 0, 10 ); 
        scene.add( directionalLight );
    //    camera.matrix.setPosition(new THREE.Vector3(0,0,5));
        camera.position.x = 00;
        camera.position.y = 00;
        camera.position.z = 20;


        camera.lookAt(new THREE.Vector3(0,0,0))

        scene.add( camera );

        cube = new Cube(scene,3);

        scene.add(cube.objects);
        projector = new THREE.Projector();

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        document.addEventListener( 'mousemove', onDocumentMouseMove, false );


        window.addEventListener( 'resize', onWindowResize, false );


    }

    function animate() {

        // note: three.js includes requestAnimationFrame shim
        requestAnimationFrame( animate );
        render();

    }

    function render() {
       //cube.applyMatrix(matrix);
      // cube.rotateLayer('y',1,0.01)
       // cube.rotateLayer('y',0,0.01)

       scene.updateMatrix();
       renderer.render( scene, camera );
    }


    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseMove( event){
      if(mouseButtonDown == true){
        event.preventDefault();
      //  console.log(event.x, event.y, event.button);
        if (previousEvent != undefined){
            var matrix = new THREE.Matrix4();
            var rotationAngle = new THREE.Vector3((event.y - previousEvent.y) /200, (event.x - previousEvent.x)/200, 0);
            matrix.setRotationFromEuler(rotationAngle);
           // if (cube.globalRotationAngle == undefined) {cube.globalRotationAngle = new THREE.Vector3();}
            cube.globalRotationAngle.addSelf(rotationAngle);                   
            cube.applyMatrix(matrix);
        }
        previousEvent = event;
      }
    }

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        mouseDownAt = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1,0);
        var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );

        projector.unprojectVector( vector, camera );

        var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

        var intersects = ray.intersectObjects(cube.cubies_meshes);

        if ( intersects.length > 0 ) {
            console.log("---")
            cube.clickedPosition = intersects[0].object.parent.matrix.getPosition().clone();
            var r = intersects[0].object.matrixWorld.clone()
            cube.clickedPoint = intersects[0];
          //  r.multiplySelf(intersects[0].object.parent.parent.matrix)
            r.setPosition(new THREE.Vector3(0,0,0));  
            cube.clickedOrientation =  r.multiplyVector3(new THREE.Vector3(0,0,1)).clone();
            cube.clickedCubieMatrix = r; 
           // console.log("normal: "+Math.round(cube.clickedOrientation.x)+","+Math.round(cube.clickedOrientation.y)+','+Math.round(cube.clickedOrientation.z));
 

            //intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
        }else{
           mouseButtonDown = true;
        }

      
      }

    function onDocumentMouseUp( event){
        event.preventDefault();
        if (!mouseButtonDown){
          mouseUpAt = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0)
          directionVector =  mouseUpAt.sub(mouseDownAt, mouseUpAt,0).normalize();

         rotateAngle2(directionVector);
        }
        mouseButtonDown = false;
        previousEvent = undefined;

    }

    function rotateAngle2(vector){
      o = cube.clickedOrientation;
      x = new THREE.Vector3(1,0,0);
      y = new THREE.Vector3(0,1,0);

      var twoDimensionsDirections = [x.clone(), x.negate().clone(), y.clone(), y.negate().clone()];

      var maxLength2D = 0;


      for (i=0; i < twoDimensionsDirections.length; i++){
          length = twoDimensionsDirections[i].clone().addSelf(vector).length();
          if (length > maxLength2D){
            maxLength2D = length;
            var twoDimensionsDirectionsPosition = i;
          }
      }
      console.log("rotate axis : "+ twoDimensionsDirectionsPosition);
        switch(twoDimensionsDirectionsPosition){
            case 0:
             // layer = (eval("cube.clickedPosition."+r[0])+2)/2;
              direction = new THREE.Vector3(0,-1,0);
              direction = getClickedFaceMatrix().multiplyVector3(direction);
              r = getRotate(direction);
              layer = (eval("cube.clickedPosition."+r[0])+2)/2;
             // console.log("LEEEFT "+r[0]);              
              cube.rotateLayer(r[0],Math.round(layer),r[1]);
            break;
            case 1:
              //layer = (cube.clickedPosition.y+2)/2;  
              direction = new THREE.Vector3(0,1,0);
              direction = getClickedFaceMatrix().multiplyVector3(direction);
              r = getRotate(direction);
              layer = (eval("cube.clickedPosition."+r[0])+2)/2;
              cube.rotateLayer(r[0],Math.round(layer),r[1]);
            break;
            case 2:
              //layer = (cube.clickedPosition.x+2)/2;
              direction = new THREE.Vector3(1,0,0);
              direction = getClickedFaceMatrix().multiplyVector3(direction);
              r = getRotate(direction);
              layer = (eval("cube.clickedPosition."+r[0])+2)/2;
              cube.rotateLayer(r[0],Math.round(layer),r[1]);
            break;
            case 3:
              //layer = (cube.clickedPosition.x+2)/2;
              direction = new THREE.Vector3(-1,0,0);
              direction = getClickedFaceMatrix().multiplyVector3(direction);
              r = getRotate(direction);  
              layer = (eval("cube.clickedPosition."+r[0])+2)/2;
              cube.rotateLayer(r[0],Math.round(layer),r[1]);
            break;
          } 
    }


    function getClickedFaceMatrix(){
      cubeMatrix = new THREE.Matrix4();
      
      var threeDimensionsAxises =[cubeMatrix.getColumnX().clone(),
                                  cubeMatrix.getColumnX().clone().negate(),
                                  cubeMatrix.getColumnY().clone(),
                                  cubeMatrix.getColumnY().clone().negate(),
                                  cubeMatrix.getColumnZ().clone(),
                                  cubeMatrix.getColumnZ().clone().negate()];
      
      var maxLength3D = 0;
      for (i=0; i < threeDimensionsAxises.length; i++){
          length = threeDimensionsAxises[i].clone().addSelf(cube.clickedOrientation).length();
          if (length > maxLength3D){
            maxLength3D = length;
            var threeDimensionsAxisesPosition = i;
          }
      }
      faceMatrix = new THREE.Matrix4();
      switch (threeDimensionsAxisesPosition){
        case 0:
          console.log("LEFT");
          return faceMatrix.setRotationFromEuler(new THREE.Vector3(0, Math.PI/2, 0));
          break;
        case 1:
          console.log("RIGHT");
          return faceMatrix.setRotationFromEuler(new THREE.Vector3(0, -Math.PI/2, 0));
          break;
        case 2:
          console.log("UP");
          return faceMatrix.setRotationFromEuler(new THREE.Vector3(Math.PI/2, 0, 0));
          break;  
        case 3:
          console.log("DOWN");
          return faceMatrix.setRotationFromEuler(new THREE.Vector3(Math.PI/2, 0, 0));
          break;  
        case 4:
          console.log("FRONT");
          return faceMatrix.setRotationFromEuler(new THREE.Vector3(0, 0, 0));

          break;
        case 5:
          console.log("BACK");
          return faceMatrix.setRotationFromEuler(new THREE.Vector3(0, 0, Math.PI));
          break;    
      }


    }

    function getRotate(axis){

      var cubeMatrix = cube.getMatrix()
      var threeDimensionsAxises =[cubeMatrix.getColumnX().clone(),
                                  cubeMatrix.getColumnX().clone().negate(),
                                  cubeMatrix.getColumnY().clone(),
                                  cubeMatrix.getColumnY().clone().negate(),
                                  cubeMatrix.getColumnZ().clone(),
                                  cubeMatrix.getColumnZ().clone().negate()];
      var maxLength3D = 0;
      for (i=0; i < threeDimensionsAxises.length; i++){
          length = threeDimensionsAxises[i].clone().addSelf(axis).length();
          if (length > maxLength3D){
            maxLength3D = length;
            var threeDimensionsAxisesPosition = i;
          }
      }
      switch (threeDimensionsAxisesPosition){
        case 0:
         // console.log("LEFT");
          return ['x', Math.PI/2];
          break;
        case 1:
         // console.log("RIGHT");
          return ['x', -Math.PI/2];
          break;
        case 2:
         // console.log("UP");
          return ['y', Math.PI/2];
          break;  
        case 3:
         // console.log("DOWN");
          return ['y', -Math.PI/2];
          break;  
        case 4:
         // console.log("FRONT");
          return ['z', Math.PI/2];
          break;
        case 5:
         // console.log("BACK");
          return ['z', -Math.PI/2];
          break;    
      }                            
    }


    function logV(name,v){
      console.log(name+(v.x)+","+(v.y)+','+(v.z));

    }


</script>