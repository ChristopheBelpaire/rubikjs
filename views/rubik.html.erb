<script src="/javascripts/three.js/build/Three.js"></script>
<body>

</body>    

<script>

    var camera, scene, renderer,
    geometry, material, mesh;
            var matrix = new THREE.Matrix4();
        //m.makeRotationY(0.1);
        //matrix.makeRotationX(0.01); 
        matrix.setRotationFromEuler(new THREE.Vector3(0,0.01,0))
        //matrix.makeRotationY(0.01); 
        //matrix.multiplySelf(matrix.makeRotationX(0.01)); 

    
    init();
    animate();
 
    function Cubie(cube, type, orientation, position, color_front, color_up, color_side, post_rotation_matrix){
      this.all_meshes = new THREE.Object3D();

      this.prepare_mesh = function(geometry, color, orientation, post_rotation_matrix){
        mesh = new THREE.Mesh(geometry, Cubie.prototype.materials[color]);
        mesh_matrix = new THREE.Matrix4();
        if (orientation != undefined){
          mesh_matrix.setRotationFromEuler(orientation);
        }
        mesh_matrix.multiply(scope.matrix, mesh_matrix);
        if (post_rotation_matrix != undefined){
          mesh_matrix.multiply(post_rotation_matrix,mesh_matrix);       
        }; 
        mesh.applyMatrix(mesh_matrix);
        scope.all_meshes.add(mesh);
      }  

      this.load_mesh = function (type, color, orientation, post_orientation_matrix ){
        if (Cubie.prototype.mesh_files[type] == undefined) {
            loader.load(Cubie.prototype.mesh_filenames[type], function(geometry){
            Cubie.prototype.mesh_files[type] = geometry;
            scope.prepare_mesh(geometry, color, orientation, post_rotation_matrix);
          });
        }
       else{
         scope.prepare_mesh(geometry, color, orientation, post_rotation_matrix);
       }   
      }

      this.applyMatrix = function applyMatrix(matrix){
        this.all_meshes.applyMatrix(matrix);
      } 
       
      this.type = type;
      this.orientation = orientation;


      if( typeof Cubie.prototype.initialized == "undefined" ) { 
        Cubie.prototype.initialized  = 0;
        Cubie.prototype.mesh_files = [];
        Cubie.prototype.materials = [new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffffff, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xff0000, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0x00ff00, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0x0000ff, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffff00, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffa500, overdraw: true})]
        Cubie.prototype.mesh_filenames = ['rubik_corner.js','rubik_edge.js','rubik_side.js','sticker.js'];
        Cubie.prototype.initialized = true;
      }; 

      var scope = this;
      this.matrix = new THREE.Matrix4();
      this.matrix.setRotationFromEuler(orientation);
      this.matrix.setPosition(position);
      
      this.load_mesh(type, Cubie.BLACK);  
      
      if (color_front != undefined){
          this.load_mesh(Cubie.STICKER, color_front, new THREE.Vector3(0,0,0), post_rotation_matrix);
      }
      if (color_up != undefined){
        this.load_mesh(Cubie.STICKER, color_up, new THREE.Vector3(-Math.PI/2,0,0), post_rotation_matrix);
      }
      if (color_side != undefined){
        this.load_mesh(Cubie.STICKER, color_side, new THREE.Vector3(0, Math.PI/2,0), post_rotation_matrix);
      }
      cube.objects.add(this.all_meshes);
       
    };

    function Cube(scene,size){
      this.objects = new THREE.Object3D();
      this.scene = scene;
      this.init_center = function (orientation, color){

        center_x = -this.max_position +2;
        center_y = -this.max_position +2;
        center_z = this.max_position;
        i=this.cubies.length;

        post_rotation_matrix = new THREE.Matrix4();
        post_rotation_matrix.setRotationFromEuler(orientation);
        
        for(x = 0; x < size -2; x++){
          for(y = 0; y < size -2; y++){
            this.cubies[i++] = new Cubie(this, Cubie.SIDE, new THREE.Vector3(0,0,0), new THREE.Vector3(center_x,center_y,center_z), color, null, null, post_rotation_matrix);
            center_x+=2;
          }
          center_y+=2;
          center_x= -this.max_position +2;
        }        
      }

      this.init_border = function (orientation, color_front, color_up){
        center_x = -this.max_position +2;
        center_y = this.max_position;
        center_z = this.max_position;
        i=this.cubies.length;

        post_rotation_matrix = new THREE.Matrix4();
        post_rotation_matrix.setRotationFromEuler(orientation);
        
        for(x = 0; x < size -2; x++){
          this.cubies[i++] = new Cubie(this, Cubie.EDGE, new THREE.Vector3(0,0,0), new THREE.Vector3(center_x,center_y,center_z), color_front, color_up, null, post_rotation_matrix);
          center_x+=2;
        }
      }

      this.getLayer= function(axis, position){
         coordinate_position = -this.max_position + position*2;
         var layer = new Array();
         //scene.updateMatrix();

         for (i=0; i < this.cubies.length; i++){
            this.cubies[i].all_meshes.updateMatrix();
            p = this.cubies[i].all_meshes.matrix.getPosition();
            if(eval('p.'+axis) == coordinate_position) { layer.push(this.cubies[i]);}
         }
         return layer; 
      } 

      this.rotateLayer = function(axis,position, angle){
        var m = new THREE.Matrix4();
        switch(axis){
          case 'x':
            m.setRotationFromEuler(new THREE.Vector3(angle,0,0));
            break;
          case 'y':
            m.setRotationFromEuler(new THREE.Vector3(0,angle,0));
            break;          
          case 'z':
            m.setRotationFromEuler(new THREE.Vector3(0,0,angle));
            break;          
        };    
    //    coordinate_position = -this.max_position + position*2;
    //    for (i=0; i < this.cubies.length; i++){
    //      p = this.cubies[i].all_meshes.matrix.getPosition();
    //      if(eval('p.'+axis) == coordinate_position) { this.cubies[i].all_meshes.applyMatrix(m);}
     //   }

        layer = this.getLayer(axis, position);
        for (i=0; i < layer.length; i++){
          layer[i].all_meshes.applyMatrix(m);
        }
      }

      this.size = size;
      this.mesh = 
      this.cubies = new Array();


      this.half_width = Math.floor(size/2); 
      this.max_position = this.half_width*2 - (1- size%2);
      //front upper left
      position = new THREE.Vector3(-this.max_position , this.max_position, this.max_position)  
      this.cubies[0] = new Cubie(this, Cubie.CORNER, new THREE.Vector3(0,0,Math.PI / 2),position, Cubie.RED, Cubie.YELLOW,Cubie.GREEN);
      //front upper right
      position = new THREE.Vector3(this.max_position , this.max_position, this.max_position)  
      this.cubies[1] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,0),position, Cubie.RED, Cubie.GREEN, Cubie.WHITE);
      //front bottom left
      position = new THREE.Vector3(-this.max_position , -this.max_position, this.max_position)  
      this.cubies[2] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,-Math.PI), position, Cubie.RED, Cubie.BLUE,Cubie.YELLOW);
      //front bottom right
      position = new THREE.Vector3(this.max_position , -this.max_position, this.max_position)  
      this.cubies[3]= new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,-Math.PI /2), position, Cubie.RED, Cubie.WHITE, Cubie.BLUE);

      //back upper left
      position = new THREE.Vector3(-this.max_position , this.max_position, -this.max_position)  
      this.cubies[4] = new Cubie(this, Cubie.CORNER, new THREE.Vector3(Math.PI,0,Math.PI),position, Cubie.ORANGE, Cubie.GREEN,Cubie.YELLOW);
      //back upper right
      position = new THREE.Vector3(this.max_position , this.max_position, -this.max_position)  
      this.cubies[5] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0,-Math.PI/2),position, Cubie.ORANGE, Cubie.WHITE, Cubie.GREEN);
   
      //back bottom left
      position = new THREE.Vector3(-this.max_position , -this.max_position, -this.max_position)  
      this.cubies[6] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0,-3/2 *Math.PI), position, Cubie.ORANGE, Cubie.YELLOW, Cubie.BLUE);
   
      //back bottom right
      position = new THREE.Vector3(this.max_position , -this.max_position, -this.max_position)  
      this.cubies[7]= new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0, 0 ), position, Cubie.ORANGE, Cubie.BLUE, Cubie.WHITE);

      this.init_center(new THREE.Vector3(0,0,0),Cubie.RED);
      this.init_center(new THREE.Vector3(Math.PI/2,0,0),Cubie.BLUE);
      this.init_center(new THREE.Vector3(-Math.PI/2,0,0),Cubie.GREEN);
      this.init_center(new THREE.Vector3(Math.PI,0,0),Cubie.ORANGE);

      this.init_center(new THREE.Vector3(0,-Math.PI/2,0),Cubie.YELLOW);
      this.init_center(new THREE.Vector3(0,Math.PI/2,0),Cubie.WHITE);

      this.init_border(new THREE.Vector3(0,0,0),Cubie.RED, Cubie.GREEN);
      this.init_border(new THREE.Vector3(Math.PI/2,0,0), Cubie.BLUE, Cubie.RED);
      this.init_border(new THREE.Vector3(-Math.PI/2,0,0), Cubie.GREEN, Cubie.ORANGE);
      this.init_border(new THREE.Vector3(Math.PI,0,0), Cubie.ORANGE, Cubie.BLUE);

      this.init_border(new THREE.Vector3(0,-Math.PI/2,0),Cubie.YELLOW, Cubie.GREEN);
      this.init_border(new THREE.Vector3(0,Math.PI/2,0),Cubie.WHITE, Cubie.GREEN);

      this.init_border(new THREE.Vector3(Math.PI/2,-Math.PI/2,0),Cubie.YELLOW, Cubie.RED);
      this.init_border(new THREE.Vector3(Math.PI/2,Math.PI/2,0),Cubie.WHITE, Cubie.RED);

      this.init_border(new THREE.Vector3(-Math.PI/2,-Math.PI/2,0),Cubie.YELLOW, Cubie.ORANGE);
      this.init_border(new THREE.Vector3(-Math.PI/2,Math.PI/2,0),Cubie.WHITE, Cubie.ORANGE);

      this.init_border(new THREE.Vector3(Math.PI,-Math.PI/2,0),Cubie.YELLOW, Cubie.BLUE);
      this.init_border(new THREE.Vector3(Math.PI,Math.PI/2,0),Cubie.WHITE, Cubie.BLUE);

      this.applyMatrix=  function applyMatrix(matrix){
        this.objects.applyMatrix(matrix); 
      }

    }

     
    function init() {
        Cubie.CORNER = 0;
        Cubie.EDGE = 1;
        Cubie.SIDE= 2;
        Cubie.STICKER = 3;

        Cubie.BLACK = 0;
        Cubie.WHITE = 1;
        Cubie.RED =   2;
        Cubie.GREEN = 3;
        Cubie.BLUE =  4;
        Cubie.YELLOW =5;
        Cubie.ORANGE =6; 

        loader = new THREE.JSONLoader();

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 10;
        //camera.position.x = 10;
        //camera.position.y = 10;
        
        scene.add( camera );

        cube = new Cube(scene,3);
        scene.add(cube.objects);
 
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );

    }

    function animate() {

        // note: three.js includes requestAnimationFrame shim
        requestAnimationFrame( animate );
        render();

    }

    function render() {
       //cube.applyMatrix(matrix);
       //cube.rotateLayer('y',1,0.01)
       // cube.rotateLayer('y',0,0.01)

       scene.updateMatrix();
       renderer.render( scene, camera );
    }
</script>