<script src="/javascripts/three.js/build/Three.js"></script>

<body style ='margin:0;'>

</body>    

<script>

    var camera, scene, renderer,
    geometry, material, mesh;
            var matrix = new THREE.Matrix4();
        //m.makeRotationY(0.1);
        //matrix.makeRotationX(0.01); 
        matrix.setRotationFromEuler(new THREE.Vector3(0.0,0.01,0.0))
        //matrix.makeRotationY(0.01); 
        //matrix.multiplySelf(matrix.makeRotationX(0.01)); 

    
    init();
    animate();
 
    function Cubie(cube, type, orientation, position, color_front, color_up, color_side, post_rotation_matrix, meshes_array){
      this.all_meshes = new THREE.Object3D();

      this.prepare_mesh = function(geometry, color, orientation, meshes_array){
        var mesh = new THREE.Mesh(geometry, Cubie.prototype.materials[color].clone());
        var mesh_matrix = new THREE.Matrix4();
        if (orientation != undefined){
          mesh_matrix.setRotationFromEuler(orientation);
        }
        mesh.applyMatrix(mesh_matrix);
        scope.all_meshes.add(mesh);
        if (meshes_array != undefined){
          meshes_array.push(mesh);
        }
        mesh.cubie = this;
        mesh.color = color;
      }  

      this.load_mesh = function (type, color, orientation, meshes_array ){
        if (Cubie.prototype.mesh_files[type] == undefined) {
            loader.load(Cubie.prototype.mesh_filenames[type], function(geometry){
            Cubie.prototype.mesh_files[type] = geometry;
            scope.prepare_mesh(geometry, color, orientation, meshes_array);
          });
        }
       else{
         scope.prepare_mesh(geometry, color, orientation, meshes_array);
       }   
      }

      this.applyMatrix = function applyMatrix(matrix){
        this.all_meshes.applyMatrix(matrix);
      } 
       
      this.type = type;
      this.orientation = orientation;


      if( typeof Cubie.prototype.initialized == "undefined" ) { 
        Cubie.prototype.initialized  = 0;
        Cubie.prototype.mesh_files = [];
        Cubie.prototype.materials = [new THREE.MeshBasicMaterial( { color: 0x000000, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffffff, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xff0000, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0x00ff00, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0x0000ff, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffff00, overdraw: true}),
                                     new THREE.MeshBasicMaterial( { color: 0xffa500, overdraw: true})]
        Cubie.prototype.mesh_filenames = ['rubik_corner.js','rubik_edge.js','rubik_side.js','sticker2.js'];
        Cubie.prototype.initialized = true;
      }; 

      var scope = this;
      this.matrix = new THREE.Matrix4();
      this.matrix.setRotationFromEuler(orientation);
      this.matrix.setPosition(position);
      
      this.load_mesh(type, Cubie.BLACK);  
      
      if (color_front != undefined){
          this.load_mesh(Cubie.STICKER, color_front, new THREE.Vector3(0,0,0), cube.cubies_meshes);
      }
      if (color_up != undefined){
        this.load_mesh(Cubie.STICKER, color_up, new THREE.Vector3(-Math.PI/2,0,0), cube.cubies_meshes);
      }
      if (color_side != undefined){
        this.load_mesh(Cubie.STICKER, color_side, new THREE.Vector3(0, Math.PI/2,0), cube.cubies_meshes);
      }

      this.all_meshes.applyMatrix(this.matrix);
      if (post_rotation_matrix != undefined){
        this.all_meshes.applyMatrix(post_rotation_matrix);
      }
      cube.objects.add(this.all_meshes);
    };

    function Cube(scene,size){
      this.cubies_meshes = [];
      this.objects = new THREE.Object3D();
      this.scene = scene;
      this.init_center = function (orientation, color){

        center_x = -this.max_position +2;
        center_y = -this.max_position +2;
        center_z = this.max_position;
        i=this.cubies.length;

        post_rotation_matrix = new THREE.Matrix4();
        post_rotation_matrix.setRotationFromEuler(orientation);
        
        for(x = 0; x < size -2; x++){
          for(y = 0; y < size -2; y++){
            this.cubies[i++] = new Cubie(this, Cubie.SIDE, new THREE.Vector3(0,0,0), new THREE.Vector3(center_x,center_y,center_z), color, null, null, post_rotation_matrix);
            center_x+=2;
          }
          center_y+=2;
          center_x= -this.max_position +2;
        }        
      }

      this.init_border = function (orientation, color_front, color_up){
        center_x = -this.max_position +2;
        center_y = this.max_position;
        center_z = this.max_position;
        i=this.cubies.length;

        post_rotation_matrix = new THREE.Matrix4();
        post_rotation_matrix.setRotationFromEuler(orientation);
        
        for(x = 0; x < size -2; x++){
          this.cubies[i++] = new Cubie(this, Cubie.EDGE, new THREE.Vector3(0,0,0), new THREE.Vector3(center_x,center_y,center_z), color_front, color_up, null, post_rotation_matrix);
          center_x+=2;
        }
      }

      this.getLayer= function(axis, position){
         coordinate_position = -this.max_position + position*2;
         var layer = new Array();

         for (i=0; i < this.cubies.length; i++){
            p = this.cubies[i].all_meshes.matrix.getPosition();
            if(Math.round(eval('p.'+axis)) == coordinate_position) { layer.push(this.cubies[i]);}
         }
         return layer; 
      } 

      this.rotateLayer = function(axis,position, angle){
        var m = new THREE.Matrix4();
        switch(axis){
          case 'x':
            m.setRotationFromEuler(new THREE.Vector3(angle,0,0));
            break;
          case 'y':
            m.setRotationFromEuler(new THREE.Vector3(0,angle,0));
            break;          
          case 'z':
            m.setRotationFromEuler(new THREE.Vector3(0,0,angle));
            break;          
        };    

        layer = this.getLayer(axis, position);
        for (i=0; i < layer.length; i++){
          layer[i].all_meshes.applyMatrix(m);
        }
      }

      this.size = size;
      this.mesh = 
      this.cubies = new Array();


      this.half_width = Math.floor(size/2); 
      this.max_position = this.half_width*2 - (1- size%2);
  
      //front upper left
      position = new THREE.Vector3(-this.max_position , this.max_position, this.max_position)  
      this.cubies[0] = new Cubie(this, Cubie.CORNER, new THREE.Vector3(0,0,Math.PI / 2),position, Cubie.RED, Cubie.YELLOW,Cubie.GREEN);
      //front upper right
      position = new THREE.Vector3(this.max_position , this.max_position, this.max_position)  
      this.cubies[1] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,0),position, Cubie.RED, Cubie.GREEN, Cubie.WHITE);
      //front bottom left
      position = new THREE.Vector3(-this.max_position , -this.max_position, this.max_position)  
      this.cubies[2] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,-Math.PI), position, Cubie.RED, Cubie.BLUE,Cubie.YELLOW);
      //front bottom right
      position = new THREE.Vector3(this.max_position , -this.max_position, this.max_position)  
      this.cubies[3]= new Cubie(this, Cubie.CORNER,new THREE.Vector3(0,0,-Math.PI /2), position, Cubie.RED, Cubie.WHITE, Cubie.BLUE);

      //back upper left
      position = new THREE.Vector3(-this.max_position , this.max_position, -this.max_position)  
      this.cubies[4] = new Cubie(this, Cubie.CORNER, new THREE.Vector3(Math.PI,0,Math.PI),position, Cubie.ORANGE, Cubie.GREEN,Cubie.YELLOW);
      //back upper right
      position = new THREE.Vector3(this.max_position , this.max_position, -this.max_position)  
      this.cubies[5] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0,-Math.PI/2),position, Cubie.ORANGE, Cubie.WHITE, Cubie.GREEN);
   
      //back bottom left
      position = new THREE.Vector3(-this.max_position , -this.max_position, -this.max_position)  
      this.cubies[6] = new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0,-3/2 *Math.PI), position, Cubie.ORANGE, Cubie.YELLOW, Cubie.BLUE);
   
      //back bottom right
      position = new THREE.Vector3(this.max_position , -this.max_position, -this.max_position)  
      this.cubies[7]= new Cubie(this, Cubie.CORNER,new THREE.Vector3(Math.PI,0, 0 ), position, Cubie.ORANGE, Cubie.BLUE, Cubie.WHITE);

      this.init_center(new THREE.Vector3(0,0,0),Cubie.RED);
      this.init_center(new THREE.Vector3(Math.PI/2,0,0),Cubie.BLUE);
      this.init_center(new THREE.Vector3(-Math.PI/2,0,0),Cubie.GREEN);
      this.init_center(new THREE.Vector3(Math.PI,0,0),Cubie.ORANGE);

      this.init_center(new THREE.Vector3(0,-Math.PI/2,0),Cubie.YELLOW);
      this.init_center(new THREE.Vector3(0,Math.PI/2,0),Cubie.WHITE);

      this.init_border(new THREE.Vector3(0,0,0),Cubie.RED, Cubie.GREEN);
      this.init_border(new THREE.Vector3(Math.PI/2,0,0), Cubie.BLUE, Cubie.RED);
      this.init_border(new THREE.Vector3(-Math.PI/2,0,0), Cubie.GREEN, Cubie.ORANGE);
      this.init_border(new THREE.Vector3(Math.PI,0,0), Cubie.ORANGE, Cubie.BLUE);

      this.init_border(new THREE.Vector3(0,-Math.PI/2,0),Cubie.YELLOW, Cubie.GREEN);
      this.init_border(new THREE.Vector3(0,Math.PI/2,0),Cubie.WHITE, Cubie.GREEN);

      this.init_border(new THREE.Vector3(0,0,Math.PI/2),Cubie.RED, Cubie.YELLOW);
      this.init_border(new THREE.Vector3(0,0,-Math.PI/2),Cubie.RED, Cubie.WHITE);

      this.init_border(new THREE.Vector3(0,Math.PI,Math.PI/2),Cubie.ORANGE, Cubie.WHITE);
      this.init_border(new THREE.Vector3(0,Math.PI,-Math.PI/2),Cubie.ORANGE, Cubie.YELLOW);

      this.init_border(new THREE.Vector3(Math.PI,-Math.PI/2,0),Cubie.YELLOW, Cubie.BLUE);
      this.init_border(new THREE.Vector3(Math.PI,Math.PI/2,0),Cubie.WHITE, Cubie.BLUE);

      this.applyMatrix=  function applyMatrix(matrix){
        this.objects.applyMatrix(matrix); 
      }

    }

     
    function init() {
        Cubie.CORNER = 0;
        Cubie.EDGE = 1;
        Cubie.SIDE= 2;
        Cubie.STICKER = 3;

        Cubie.BLACK = 0;
        Cubie.WHITE = 1;
        Cubie.RED =   2;
        Cubie.GREEN = 3;
        Cubie.BLUE =  4;
        Cubie.YELLOW =5;
        Cubie.ORANGE =6; 

        loader = new THREE.JSONLoader();

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );

    //    camera.matrix.setPosition(new THREE.Vector3(0,0,5));
        camera.position.x = 10;
        camera.position.y = 10;
        camera.position.z = 10;


        camera.lookAt(new THREE.Vector3(0,0,0))

        scene.add( camera );

        cube = new Cube(scene,3);

        scene.add(cube.objects);
        projector = new THREE.Projector();

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );
        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        window.addEventListener( 'resize', onWindowResize, false );


    }

    function animate() {

        // note: three.js includes requestAnimationFrame shim
        requestAnimationFrame( animate );
        render();

    }

    function render() {
     //  cube.applyMatrix(matrix);
       //cube.rotateLayer('y',1,0.01)
       // cube.rotateLayer('y',0,0.01)

       scene.updateMatrix();
       renderer.render( scene, camera );
    }


    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onDocumentMouseDown( event ) {

        event.preventDefault();

        var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );

        projector.unprojectVector( vector, camera );

        var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

        var intersects = ray.intersectObjects(cube.cubies_meshes);

        if ( intersects.length > 0 ) {
            console.log("---")
            o = intersects[0].object.parent.matrix.getPosition();
            var r = intersects[0].object.matrixWorld.clone()
            r.setPosition(new THREE.Vector3(0,0,0));  
            var n=  r.multiplyVector3(new THREE.Vector3(0,0,1))
            console.log("normal: "+Math.round(n.x)+","+Math.round(n.y)+','+Math.round(n.z));
            console.log("position: "+Math.round(o.x)+","+Math.round(o.y)+','+Math.round(o.z));

            //intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
        }

      
      }



</script>